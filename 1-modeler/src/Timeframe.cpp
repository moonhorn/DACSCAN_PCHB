// **************************************************************************
//  File       [main.cpp]
//  Author     [Yu-Hao Ho]
//  Synopsis   [The implementation of worker ant function]
//  Modify     [2015/03/20 Yu-Hao Ho]
// **************************************************************************

#include "Timeframe.h"
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>

using namespace std;

//////// GateType //////////

string to_string(int i) {
	stringstream ss;
	ss << i;
	return ss.str();
}

// Constructor
PCHBize::PCHBize(string name) {
		moduleName = name;
}

int PCHBize::InsertGate(string gateName, int gateType) {
	GateList.push_back(PCHBgate(gateName,gateType));
	return GateList.size()-1;
	
}

void PCHBize::updateINOUT(int ID, string name, int INOUT){
	if(INOUT == 0)
		GateList[ID].InsertInput(name);
	else
		GateList[ID].InsertOutput(name);
}

int	PCHBize::searchWireName(string name ){
	if(wireName.empty()){
		wireName.push_back(name);
		return 0;
	}
	for(int j = 0;  j < wireName.size(); j++){
		if(wireName[j].compare(name)==0)
			return 1;
	}
	wireName.push_back(name);
	return 0;
}

string PCHBize::catchGateType(int value){
	switch (value){
		case 1:
			return "INV";
		case 2:
			return "AND2";
		case 3:
			return "AND3";
		case 4:
			return "AND4";
		case 5:
			return "NAND2";
		case 6:
			return "NAND3";
		case 7:
			return "NAND4";
		case 8:
			return "OR2";
		case 9:
			return "OR3";
		case 10:
			return "OR4";
		case 11:
			return "NOR2";
		case 12:
			return "NOR3";
		case 13:
			return "NOR4";
		case 14:
			return "XOR2";
		case 15:
			return "XOR3";
		case 16:
			return "XNOR2";
		case 17:
			return "XNOR3";
		case 18:
			return "DFF";
	}
	return "Not Defined";
}			

int	PCHBize::catchINOUTType(string INOUT){
	if(INOUT.compare("A1")==0)
		return 0;
	else if(INOUT.compare("A2")==0)
		return 0;
	else if(INOUT.compare("A3")==0)
		return 0;
	else if(INOUT.compare("A4")==0)
		return 0;
	else if(INOUT.compare("A")==0)
		return 0;
	else if(INOUT.compare("B")==0)
		return 0;
	else if(INOUT.compare("D")==0)
		return 0;
	else if(INOUT.compare("ZN")==0)
		return 1;
	else if(INOUT.compare("Q")==0)
		return 1;
	else
		return 2;
	
}

void PCHBize::printModNetlist(string OUT){
	/*fstream fout;
	fout.open(OUT.c_str(), ios::out);
	fout << "//Generated by LaDS PCHB Generator" << endl;
	fout << "module " << moduleName << "_PCHB (" << endl;
	int temp = -1;
	
	//Generate the IN/OUT List
	for(int i = 0; i < InputName.size(); i++){
		if(InputName[i].compare("CK") == 0)
			temp = i;
		else
			fout << "	" << InputName[i] << "_f," << endl;
	}
	if(temp!=-1)		//Kill the "CK" input
		InputName.erase(InputName.begin()+temp);
	for(int i = 0; i < OutputName.size(); i++){
		fout << "	" << OutputName[i] << "_f," << endl;
	}
	for(int i = 0; i < InputName.size(); i++){
		fout << "	" << InputName[i] << "_t," << endl;
	}
	for(int i = 0; i < OutputName.size(); i++){
		fout << "	" << OutputName[i] << "_t," << endl;
	}
	fout << "	ACK_O," << endl;
	fout << "	ACK_I," << endl;
	fout << "	reset);" << endl;
	fout << endl;
	
	fout << "//Input List" << endl;
	for(int i = 0; i < InputName.size(); i++){
		fout << "input " << InputName[i] << "_f," << endl;
	}
	for(int i = 0; i < InputName.size(); i++){
		fout << "input " << InputName[i] << "_t," << endl;
	}
	fout << "input ACK_O;" << endl;
	fout << "input reset;" << endl;
	fout << endl;
	
	fout << "//Output List" << endl;
	for(int i = 0; i < OutputName.size(); i++){
		fout << "output " << OutputName[i] << "_f," << endl;
	}
	for(int i = 0; i < OutputName.size(); i++){
		fout << "output " << OutputName[i] << "_t," << endl;
	}
	fout << "output ACK_I;" << endl;
	fout << endl;
	fout << endl;
    
	
	//Generate Logic
	fout << "//Logic" << endl;
	for(int i = 0; i < GateList.size(); i++){
		string temp1 = GateList[i].readOutputName(0);
		int temp2 = -1;		//store 
		int fanout = 0;
		//Connect AckR : Find all Fanout of Gate, and combine them with AND gate
		for(int j = 0; j < GateList.size(); j++){		//Check Fanout wire to Gate Input
			for(int k = 0; k < GateList[j].readInputLength(); k++){
				if(temp1.compare(GateList[j].readInputName(k))==0){
					fanout++;
					if(fanout ==1)
						temp2 = j;
					else if(fanout==2)
						fout << "AND2_X1 AckR_" << GateList[i].readGateName() << "_" << fanout << "(.A1(AckL_" << GateList[j].readGateName() <<"), .A2(AckL_" << GateList[temp2].readGateName() << "), .ZN(AckR_" << GateList[i].readGateName() << "_" << fanout << "));" <<endl;
					else{
						fout << "AND2_X1 AckR_" << GateList[i].readGateName() << "_" << fanout << "(.A1(AckR_" << GateList[i].readGateName() << "_" << fanout-1 << "), .A2(AckL_" << GateList[j].readGateName() << "), .ZN(AckR_" << GateList[i].readGateName() << "_" << fanout << "));" <<endl; 
					}
				}
			}
		}
		for(int j = 0;  j < OutputName.size(); j++){	//Check Fanout wire to PO
			if(temp1.compare(OutputName[j])==0){
				fanout++;
				if(fanout ==1){
					fout << "wire AckR_" << GateList[i].readGateName() << "_" << fanout << ";" << endl;
					fout << "assign AckR_" << GateList[i].readGateName() << "_" << fanout << " = AckR;" << endl;
				}else if(fanout==2)
					fout << "AND2_X1 AckR_" << GateList[i].readGateName() << "_" << fanout << "(.A1(AckR), .A2(AckL_" << GateList[temp2].readGateName() << "), .ZN(AckR_" << GateList[i].readGateName() << "_" << fanout << "));" <<endl;
				else{
					fout << "AND2_X1 AckR_" << GateList[i].readGateName() << "_" << fanout << "(.A1(AckR_" << GateList[i].readGateName() << "_" << fanout-1 << "), .A2(AckR), .ZN(AckR_" << GateList[i].readGateName() << "_" << fanout << "));" <<endl; 
				}
				break;
			}
		}
		if(fanout == 1){
			fout << "wire AckR_" << GateList[i].readGateName() << "_" << fanout << ";" << endl;
			fout << "assign AckR_" << GateList[i].readGateName() << "_" << fanout << " = AckL_" << GateList[temp2].readGateName() << ";" << endl;
		}
		if(GateList[i].readGateType()==18){	//Create gate - Not including Flip-Flop
			fout << "Real_" << catchGateType(GateList[i].readGateType()) << "_PCHB ";
			fout << GateList[i].readGateName() << "(.AckL(AckL_" << GateList[i].readGateName() << "), .AckR(AckR_" << GateList[i].readGateName() << "_" << fanout << "), ";
			for(int j = 0; j < GateList[i].readInputLength(); j++){
				fout << ".A" << j+1 << "_f(" << GateList[i].readInputName(j) << "_f), .A" << j+1 << "_t(" << GateList[i].readInputName(j) << "_t), ";
			}
			for(int j = 0; j < GateList[i].readOutputLength(); j++){
				fout << ".ZN_f(" << GateList[i].readOutputName(j) << "_f), .ZN_t(" << GateList[i].readOutputName(j) << "_t), ";
			}
			fout << ".reset(reset));" << endl;	
		}else{
			fout << "DUAL_REG " << GateList[i].readGateName() << "(.Ack_I(AckL_" << GateList[i].readGateName() << "), .Ack_O(AckR_" << GateList[i].readGateName() << "_" << fanout << "), .I_f(" << GateList[i].readInputName(0) << "_f), .I_t(" << GateList[i].readInputName(0);
			fout << "_t), .O_f(" << GateList[i].readOutputName(0) << "_f), .O_t(" << GateList[i].readOutputName(0) << "_t));" << endl;
		}
	}
	//Connect Lack
	int fanout2 = 0;
	for(int j = 0; j < GateList.size(); j++){	//Check Fanout wire to PO
		bool temp3 = false;
		for(int i = 0; i < InputName.size(); i++){
			if(temp3 == true)
				break;
			for(int k = 0; k < GateList[j].readInputLength(); k++){
				if(GateList[j].readInputName(k).compare(InputName[i])==0){
					temp3 = true;
					fanout2++;
					if(fanout2 == 1)
						temp = j;
					else if(fanout2==2)
						fout << "AND2_X1 AckL" << fanout2 << "(.A1(AckL_" << GateList[temp].readGateName() << "), .A2(AckL_" << GateList[j].readGateName() << "), .ZN(AckL" << fanout2 << "));" <<endl;
					else
						fout << "AND2_X1 AckL" << fanout2 << "(.A1(AckL" << fanout2-1 << "), .A2(AckL_" << GateList[j].readGateName() << "), .ZN(AckL" << fanout2 << "));" <<endl;
					break;
				}
			}
		}
	}
	fout << "assign AckL" << fanout2 << " = AckL;" << endl;
	fout.close();
	*/
}

void PCHBize::insertDfT(){
	int PPIflag, flag2;
	for(int i = GateList.size()-1; i >= 0; i--){
		if(GateList[i].readGateType()==18){	//Find DFF
			flag2 = 0;
			for(int j = OutputName.size()-1;  j >=0 ; j--){	//Deal with PPI
				if(GateList[i].readOutputName(0).compare(OutputName[j])==0){	// Check if PPI == PO
					flag2 = 1;
					PPIflag = 0;
					for(int k = 0; k < GateList.size(); k++){	//Check if PPI is needed	
						for(int l = 0; l < GateList[k].readInputLength(); l++){
							if(GateList[i].readOutputName(0).compare(GateList[k].readInputName(l))==0){ // PPI is connect to other gate so is needed
								GateList[k].modifyPPI(l);	//Modify connected gate's pin to connect PPI
								PPIflag = 1;
							}
						}
					}
					if(PPIflag == 0);	//PPI not needed
					else				//PPI is needed
						InputName.push_back(GateList[i].readOutputName(0)+"_ppi");	// Add PPI
					OutputName.erase(OutputName.begin()+j);					// Kill PO since directly connect the PPI
					break;
				}
			}
			if(flag2 == 0){	//PPI != PO
				for(int k = 0; k < GateList.size(); k++){
					for(int l = 0; l < GateList[k].readInputLength(); l++){
						if(GateList[i].readOutputName(0).compare(GateList[k].readInputName(l))==0){
							GateList[k].modifyPPI(l);	//Modify connected gate's pin to connect PPI
						}
					}
				}
				InputName.push_back(GateList[i].readOutputName(0)+"_ppi");	// Add PPI
			}
			flag2 = 0;
			for(int j = InputName.size()-1;  j >=0 ; j--){	//Deal with PPO
				if(GateList[i].readInputName(0).compare(InputName[j])==0){	// Check if PPO == PI
					flag2 = 1;
					PPIflag = 0;
					for(int k = 0; k < GateList.size(); k++){	//PPO is not needed, check if this PI is still needed
						for(int l = 0; l < GateList[k].readInputLength(); l++){
							if(InputName[j].compare(GateList[k].readInputName(l))==0){	// PI is connect to other gate so is needed
								PPIflag = 1;
								break;
								break;
							}
						}
					}
					if(PPIflag == 0)	//PI not needed
						InputName.erase(OutputName.begin()+j);	// Kill PI since only connect the PPO
					else;				//PI is needed
				}
			}
			if(flag2 == 0){	//PPO != PI
				flag2 = 0;
				for(int j = OutputName.size()-1;  j >=0 ; j--){
					if(GateList[i].readInputName(0).compare(OutputName[j])==0){	//Check if PPO is already establish ( 2 DFF receive same input)
						flag2 = 1;
						break;
					}	
				}
				if(flag2 == 0)
					OutputName.push_back(GateList[i].readInputName(0));	// add PPO
			}
			GateList.erase(GateList.begin()+i);	//Delete Flip-Flop
		}
	}
}

void PCHBize::removeExtraINV(){
	int killFlag, POkillFlag, cascadeFlag;
	for(int i = GateList.size()-1; i >= 0; i--){
		if(GateList[i].readGateType()==1){	//Find INV
			killFlag = 0;
			for(int j = GateList.size()-1; j >= 0; j--){
				if(GateList[j].readGateType()==1){	//Find another INV
					if(GateList[i].readInputName(0).compare(GateList[j].readOutputName(0))==0){	//It is directly connected from another INV
						killFlag = 1;
						cascadeFlag = 1;
						for(int k = GateList.size()-1; k >= 0; k--){	//Modify all gate it connects to
							for(int l = 0; l < GateList[k].readInputLength(); l++){
								if(GateList[i].readOutputName(0).compare(GateList[k].readInputName(l))==0)
									GateList[k].modifyPI(l,GateList[j].readInputName(0));
								if(i!=k){
									if(GateList[j].readOutputName(0).compare(GateList[k].readInputName(l))==0)
										cascadeFlag = 0;
								}
							}
							
						}
						for(int k = 0; k < OutputName.size(); k++){		//Modified PO it connects to
							if(GateList[j].readOutputName(0).compare(OutputName[k])==0)
								cascadeFlag = 0;
							if(GateList[i].readOutputName(0).compare(OutputName[k])==0){ //This INV is directly connected to PO
								POkillFlag = 0;
								for(int l = 0; l < InputName.size(); l++){	//Check if PI is directly connected to PO
									if(GateList[j].readInputName(0).compare(InputName[l])==0){	//PI is directly connect to PO after simplify, PO not needed anymore
										POkillFlag = 1;
										OutputName.erase(OutputName.begin()+k);
										break;
									}
								}
								for(int l = 0; l < OutputName.size(); l++){	//Check if PPI is already a PO
									if(GateList[j].readInputName(0).compare(OutputName[l])==0){	//PPI is already a PO, no need to reroute
										POkillFlag = 1;
										break;
									}
								}
								if(POkillFlag == 0)
									OutputName[k] = GateList[j].readInputName(0);
							}
						}
						if(cascadeFlag == 1){
							if(j < i)
								i--;
							GateList.erase(GateList.begin()+j);
						}
					}
				}
			}
			if(killFlag == 1){
				GateList.erase(GateList.begin()+i);
			}
		}
	}
}

void PCHBize::printATPGModel(int option,int Ftype ,int TF, int enLarge, int SI, string OUT1, string OUT2){	//0:STF 1:STR
	fstream fout1;
	fout1.open(OUT1.c_str(), ios::out);
	fstream fout2;
	fout2.open(OUT2.c_str(), ios::out);
	int enL = enLarge;
	fout1 << "//Generated by LaDS PCHB Generator" << endl;
	fout1 << "module " << moduleName << "_PCHB (" << endl;
	int temp = -1;
	
	wireName.clear();
	string tempWire;	

	//Generate the IN/OUT List
	for(int h = 1; h <= TF; h++){
		for(int i = 0; i < InputName.size(); i++){
			if(InputName[i].compare("CK") == 0)
				temp = i;
			else
				fout1 << "	IO_" << InputName[i] << "_f_TF" << h << "," << endl;
		}
		if(temp!=-1){		//Kill the "CK" input
			InputName.erase(InputName.begin()+temp);
			temp = -1;
		}	
		for(int i = 0; i < OutputName.size(); i++){
			fout1 << "	IO_" << OutputName[i] << "_f_TF" << h << "," << endl;
		}
		for(int i = 0; i < InputName.size(); i++){
			fout1 << "	IO_" << InputName[i] << "_t_TF" << h << "," << endl;
		}
		for(int i = 0; i < OutputName.size(); i++){
			fout1 << "	IO_" << OutputName[i] << "_t_TF" << h << "," << endl;
		}
		fout1 << "	IO_ACK_O_TF" << h << "," << endl;
		fout1 << "	IO_ACK_I_TF" << h << "," << endl;
		fout1 << "	IO_reset_TF" << h << "," << endl;
	}
	fout1 << ");" << endl;
	fout1 << endl;
	
	fout1 << "//Input List" << endl;
	for(int h = 1; h <= TF; h++){
		fout1 << "input ";
		for(int i = 0; i < InputName.size(); i++){
			if((i%1000)==999){
				fout1 << "IO_" << InputName[i] << "_f_TF" << h << ", IO_" << InputName[i] << "_t_TF" << h << ";";
				if(i!=(InputName.size()-1)){
					fout1 << endl;
					fout1 << "input ";
				}
			}else
				fout1 << "IO_" << InputName[i] << "_f_TF" << h << ", IO_" << InputName[i] << "_t_TF" << h << ", ";
		}
		fout1 << " IO_ACK_O_TF" << h << ", IO_reset_TF" << h << ";" << endl;
	}
	fout1 << endl;
	fout1 << "//Output List" << endl;
	for(int h = 1; h <= TF; h++){	
		fout1 << "output ";
		for(int i = 0; i < OutputName.size(); i++){
			if((i%1000)==999){
				fout1 << "IO_" << OutputName[i] << "_f_TF" << h << ", IO_" << OutputName[i] << "_t_TF" << h << ";";
				if(i!=(OutputName.size()-1)){
					fout1 << endl;
					fout1 << "output ";
				}
			}else
				fout1 << "IO_" << OutputName[i] << "_f_TF" << h << ", IO_" << OutputName[i] << "_t_TF" << h << ", ";
		}
		fout1 << " IO_ACK_I_TF" << h << ";" << endl;
	}
	fout1 << endl;
	
	fout1 << "assign TIE_VALUE = 1'b" << option <<";" << endl;
	if(SI == 0)
		fout1 << "assign SI = 1'bx;" << endl;
	else
		fout1 << "assign SI = 1'b0;" << endl;
	fout1 << "assign Empty = 1'b0;" << endl;
	
	for(int i = 0; i < OutputName.size(); i++){
		tempWire = OutputName[i]+"_f_TF"+to_string(enL);
		searchWireName(tempWire);
		tempWire = OutputName[i]+"_t_TF"+to_string(enL);
		searchWireName(tempWire);
		fout1 << "wire " << OutputName[i] << "_f_TF" << enL <<", " << OutputName[i] << "_t_TF" << enL;
		for(int h = 2; h <= TF; h++){
			tempWire = OutputName[i]+"_f_TF"+to_string(enL*h);
			searchWireName(tempWire);
			tempWire = OutputName[i]+"_t_TF"+to_string(enL*h);
			searchWireName(tempWire);
			fout1 << ", " << OutputName[i] << "_f_TF" << enL*h << ", " << OutputName[i] << "_t_TF" << enL*h;
		}
		fout1 << ";" << endl;
	}
	tempWire = "ACK_I_TF"+to_string(enL);
	searchWireName(tempWire);
	tempWire = "ACK_O_TF"+to_string(enL);
	searchWireName(tempWire);
	fout1 << "wire ACK_I_TF" << enL << ", ACK_O_TF" << enL;
	for(int h = 2; h <= TF; h++){
		tempWire = "ACK_I_TF"+to_string(enL*h);
		searchWireName(tempWire);
		tempWire = "ACK_O_TF"+to_string(enL*h);
		searchWireName(tempWire);
		fout1 << ", ACK_I_TF" << enL*h << ", ACK_O_TF" << enL*h;
	}
	fout1 << ";" << endl;
	
	for(int h = 1; h <= TF; h++){
		for(int q = 0; q < enL; q++){
			for(int i = 0; i < InputName.size(); i++){
				fout1 << "assign " << InputName[i] << "_f_TF" << enL*h-q << " = IO_" << InputName[i] << "_f_TF" << h << ";" << endl;
				fout1 << "assign " << InputName[i] << "_t_TF" << enL*h-q << " = IO_" << InputName[i] << "_t_TF" << h << ";" << endl;
			}
			fout1 << "assign ACK_O_TF" << enL*h-q << " = IO_ACK_O_TF" << h << ";" << endl;
			fout1 << "assign reset_TF" << enL*h-q << " = IO_reset_TF" << h << ";" << endl;
		}
		for(int i = 0; i < OutputName.size(); i++){
			fout1 << "assign IO_" << OutputName[i] << "_f_TF" << h << " = " << OutputName[i] << "_f_TF" << h*enL << ";" << endl;
			fout1 << "assign IO_" << OutputName[i] << "_t_TF" << h << " = " << OutputName[i] << "_t_TF" << h*enL << ";" << endl;
		}
		fout1 << "assign IO_ACK_I_TF" << h << " = ACK_I_TF" << h*enL << ";" << endl;
	}
	TF*=enL;
	
	fout1 << "//Logic" << endl;
	for(int i = 0; i < GateList.size(); i++){
		string temp1 = GateList[i].readOutputName(0);
		int temp2 = -1;		//store 
		int fanout = 0;
		//Connect AckR : Find all Fanout of Gate, and combine them with CEMT
		for(int j = 0; j < GateList.size(); j++){		//Check Fanout wire to Gate Input
			for(int k = 0; k < GateList[j].readInputLength(); k++){
				if(temp1.compare(GateList[j].readInputName(k))==0){
					fanout++;
					for(int h = 1; h <= TF; h++){		//Maintain Timeframe
						if(fanout == 1)
							temp2 = j;
						else if(fanout == 2){
							if(h == 1)
								fout1 << "assign AckR_" << GateList[i].readGateName() << "_TF1_FO2 = SI;" << endl;
							else
								fout1 << "CEMT2 inst_AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO2(.A1(AckL_" << GateList[j].readGateName() <<"_TF" << h-1 << "), .A2(AckL_" << GateList[temp2].readGateName() <<"_TF" << h-1 <<  "), .ZN(AckR_" << GateList[i].readGateName() << "_TF" << h  << "_FO2) , .PI(AckR_" << GateList[i].readGateName() << "_TF" << h-1 << "_FO2));" <<endl;	
						}else{
							if(h == 1)
								fout1 << "assign AckR_" << GateList[i].readGateName() << "_TF1_FO" << fanout << " = SI;" << endl;
							else
								fout1 << "CEMT2 inst_AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout << "(.A1(AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout-1 << "), .A2(AckL_" << GateList[j].readGateName() << "_TF" << h-1 << "), .ZN(AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout << "), .PI(AckR_" << GateList[i].readGateName() << "_TF" << h-1 << "_FO" << fanout << "));" <<endl; 	
						}
					}
				}
			}
		}
		if(fanout == 1){
			for(int h = 2; h <= TF; h++){
				tempWire = "AckL_"+GateList[temp2].readGateName()+"_TF"+to_string(h-1);
				if(searchWireName(tempWire) == 1);
				else
					fout1 << "wire AckL_" << GateList[temp2].readGateName() << "_TF" << h-1 << ";" << endl;
				fout1 << "assign AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO1 = AckL_" << GateList[temp2].readGateName() << "_TF" << h-1 << ";" << endl;
			}
		}
		
		//Check Fanout wire to PO
		for(int j = 0;  j < OutputName.size(); j++){	
			if(temp1.compare(OutputName[j])==0){
				fanout++;
				for(int h = 1; h <= TF; h++){		//Maintain Timeframe
					if(fanout == 1){
						fout1 << "assign AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO1 = ACK_O_TF" << h << ";" << endl;
					}else if(fanout == 2){
						if(h == 1)
							fout1 << "assign AckR_" << GateList[i].readGateName() << "_TF1_FO2 = ACK_O_TF1;" << endl;
						else
							fout1 << "CEMT2 inst_AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO2(.A1(ACK_O_TF" << h <<"), .A2(AckL_" << GateList[temp2].readGateName() <<"_TF" << h-1 <<  "), .ZN(AckR_" << GateList[i].readGateName() << "_TF" << h  << "_FO2) , .PI(AckR_" << GateList[i].readGateName() << "_TF" << h-1 << "_FO2));" <<endl;	
					}else{
						if(h == 1)
							fout1 << "assign AckR_" << GateList[i].readGateName() << "_TF1_FO" << fanout << " = ACK_O_TF1;" << endl;
						else
							fout1 << "CEMT2 inst_AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout << "(.A1(AckR_" << GateList[i].readGateName()  << "_TF" << h << "_FO" << fanout-1 << "), .A2(ACK_O_TF" << h <<"), .ZN(AckR_" << GateList[i].readGateName()  << "_TF" << h << "_FO" << fanout << "), .PI(AckR_" << GateList[i].readGateName() << "_TF" << h-1 << "_FO" << fanout << "));" <<endl; 
					}
				}
				break;
			}
		}

		// Implement Logic
		if(GateList[i].readGateType()==1){
			fout1 << "INV_PCHB_MODEL " << GateList[i].readGateName() << "(";
			for(int h = 1; h <= TF; h++){
				for(int j = 0; j < GateList[i].readInputLength(); j++){
					if(h == 1)
						fout1 << ".A" << j+1 << "_f_TF1(" << GateList[i].readInputName(j) << "_f_TF" << h <<  "), .A" << j+1 << "_t_TF1(" << GateList[i].readInputName(j) << "_t_TF" << h << "), ";
					else
						fout1 << ".A" << j+1 << "_f_TF" << h <<  "(" << GateList[i].readInputName(j) << "_f_TF" << h <<  "), .A" << j+1 << "_t_TF" << h <<  "(" << GateList[i].readInputName(j) << "_t_TF" << h << "), ";
				}
				for(int j = 0; j < GateList[i].readOutputLength(); j++){
					fout1 << ".ZN_f_TF" << h <<  "(" << GateList[i].readOutputName(j) << "_f_TF" << h <<  "), .ZN_t_TF" << h <<  "(" << GateList[i].readOutputName(j) << "_t_TF" << h;
						if((h==TF)&&(j==GateList[i].readOutputLength()-1))
							fout1 << "));" << endl;
						else
							fout1 << "), ";
				}
			}
			for(int h = 1; h <= TF; h++){	//Connect AckL
				if(h == 1)
					fout1 << "assign AckL_" << GateList[i].readGateName() << "_TF1 = SI;" << endl;
				else{
					tempWire = "AckR_"+GateList[i].readGateName()+"_TF"+to_string(h)+"_FO"+to_string(fanout);
					/*
					if(searchWireName(tempWire) == 1);
					else
						fout1 << "wire AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout << ";" << endl;
					*/
					fout1 << "assign AckL_" << GateList[i].readGateName() << "_TF" << h << " = AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout << ";" << endl;
				}
			}
		}else if(GateList[i].readGateType()!=18){	//Not including Flip-Flop
			//Create Gate
			if(Ftype==0)
				fout1 << catchGateType(GateList[i].readGateType()) << "_PCHB_STUCKAT_MODEL "; //From Here
			else
				fout1 << catchGateType(GateList[i].readGateType()) << "_PCHB_DELAY_MODEL "; //From Here
			fout1 << GateList[i].readGateName() << "(";
			for(int h = 1; h <= 17+GateList[i].readInputLength()*5; h++){
				if(GateList[i].readGateType()!=1){
					//if((h==GateList[i].readInputLength()*2+1)||(h==GateList[i].readInputLength()*2+2)||(h>GateList[i].readInputLength()*2+4)){ //Without datapath
					//if((h==GateList[i].readInputLength()*2+4)||(h==GateList[i].readInputLength()*2+3)||(h<=GateList[i].readInputLength()*2)){ //Only datapath
						if(option == 0)
							fout2 << "sa1  --  " << GateList[i].readGateName() << "/inst_model" << h << "/buffer/Z" << endl;
						else                        
							fout2 << "sa0  --  " << GateList[i].readGateName() << "/inst_model" << h << "/buffer/Z" << endl;
					//}
				}
			}
			for(int h = 1; h <= TF; h++){	//Connect AckL
				fout1 <<" .AckL_TF" << h << "(AckL_" << GateList[i].readGateName() << "_TF" << h << "), ";
				if(h == 1)
					fout1 << ".AckR_TF1(~SI), ";
				else
					fout1 << ".AckR_TF" << h << "(AckR_" << GateList[i].readGateName() << "_TF" << h << "_FO" << fanout << "), ";
				for(int j = 0; j < GateList[i].readInputLength(); j++){
					fout1 << ".A" << j+1 << "_f_TF" << h <<  "(" << GateList[i].readInputName(j) << "_f_TF" << h <<  "), .A" << j+1 << "_t_TF" << h <<  "(" << GateList[i].readInputName(j) << "_t_TF" << h << "), ";
				}
				for(int j = 0; j < GateList[i].readOutputLength(); j++){
					fout1 << ".ZN_f_TF" << h <<  "(" << GateList[i].readOutputName(j) << "_f_TF" << h <<  "), .ZN_t_TF" << h <<  "(" << GateList[i].readOutputName(j) << "_t_TF" << h <<  "), ";
				}
				fout1 << ".reset_TF" << h <<  "(reset_TF" << h <<  "),";
			}
			fout1 << ".PPI_f(SI), .PPI_t(SI), .PPI_c(SI), .Empty(Empty), .TIE_VALUE(TIE_VALUE));" << endl;
		}else;
	}
	
	//Connect Lack to PO
	int fanout2 = 0;
	for(int j = 0; j < GateList.size(); j++){	//Check Fanout wire to PO
		bool temp3 = false;
		for(int i = 0; i < InputName.size(); i++){
			if(temp3 == true)
				break;
			for(int k = 0; k < GateList[j].readInputLength(); k++){
				if(GateList[j].readInputName(k).compare(InputName[i])==0){
					temp3 = true;
					fanout2++;
					for(int h = 1; h <= TF; h++){		//Maintain Timeframe
						if(fanout2 == 1)
							temp = j;
						else if(fanout2 == 2){
							if(h == 1)
								fout1 << "CEMT2 inst_AckL_TF" << h << "_FO" << fanout2 << "(.A1(AckL_" << GateList[temp].readGateName() << "_TF" << h << "), .A2(AckL_" << GateList[j].readGateName() << "_TF" << h << "), .ZN(AckL_TF" << h << "_FO" << fanout2 << ") ,.PI(SI));" <<endl;
							else
								fout1 << "CEMT2 inst_AckL_TF" << h << "_FO" << fanout2 << "(.A1(AckL_" << GateList[temp].readGateName() << "_TF" << h << "), .A2(AckL_" << GateList[j].readGateName() << "_TF" << h << "), .ZN(AckL_TF" << h << "_FO" << fanout2 << ") ,.PI(AckL_TF" << h-1 << "_FO" << fanout2 << "));" <<endl;
						}else{
							if(h == 1)
								fout1 << "CEMT2 inst_AckL_TF" << h << "_FO" << fanout2 << "(.A1(AckL_TF" << h << "_FO" << fanout2-1 << "), .A2(AckL_" << GateList[j].readGateName() << "_TF" << h << "), .ZN(AckL_TF" << h << "_FO" << fanout2 << ") ,.PI(SI));" <<endl;
							else
								fout1 << "CEMT2 inst_AckL_TF" << h << "_FO" << fanout2 << "(.A1(AckL_TF" << h << "_FO" << fanout2-1 << "), .A2(AckL_" << GateList[j].readGateName() << "_TF" << h << "), .ZN(AckL_TF" << h << "_FO" << fanout2 << ") ,.PI(AckL_TF" << h-1 << "_FO" << fanout2 << "));" <<endl;
						}
					}
					break;
				}
			}
		}
	}
	for(int h = 1; h <= TF; h++){		//Maintain Timeframe
		if(fanout2 == 1)
			fout1 << "assign ACK_I_TF" << h << " = AckL_" << GateList[temp].readGateName() << "_TF" << h << ";" << endl;
		else
			fout1 << "assign ACK_I_TF" << h << " = AckL_TF" << h << "_FO" << fanout2 << ";" << endl;
	}
	///////////////
	
	fout1 << "endmodule" << endl;
	fout1.close();
	fout2.close();
}

int	PCHBize::calculateDepth(){
	vector<string> tempNow;
	vector<string> tempNext;
	fstream fout1;
	fout1.open("Depthreport.txt", ios::out);
	
	for(int i = GateList.size()-1; i >= 0 ; i--){	//Clear all inverter (Will damage gate tree)
		if(GateList[i].readGateType() == 1){
			for(int j = GateList.size()-1; j >= 0 ; j--){
				if(i!=j){
					for(int k = 0; k < GateList[j].readInputLength(); k++){
						if(GateList[i].readOutputName(0).compare(GateList[j].readInputName(k))==0){
							GateList[j].modifyPI(k, GateList[i].readOutputName(0));
						}
					}
				}
			}
			GateList.erase(GateList.begin()+i);
		}
	}
	
	//Forward Depth
	for(int i = 0; i < GateList.size(); i++){	//Clean depth
		GateList[i].updateDepth(-1);
	}	
	for(int i = 0; i < GateList.size(); i++){	//Define first class
		for(int j = 0; j < GateList[i].readInputLength(); j++){
			for(int k = 0; k < InputName.size(); k++){
				if(GateList[i].readInputName(j).compare(InputName[k])==0){
					GateList[i].updateDepth(1);
					tempNow.push_back(GateList[i].readOutputName(0));
					break;
					break;
				}
			}
		}
	}
	
	for(int g = 2; g < 100; g++){
		tempNext.clear();
		for(int i = 0; i < GateList.size(); i++){	//Define first class
			for(int j = 0; j < GateList[i].readInputLength(); j++){
				for(int k = 0; k < tempNow.size(); k++){
					if(GateList[i].readInputName(j).compare(tempNow[k])==0){
						GateList[i].updateDepth(g);
						tempNext.push_back(GateList[i].readOutputName(0));
						break;
						break;
					}
				}
			}
		}
		if(tempNext.empty()){
			for(int t = 1; t <= g-1; t++){
				fout1 << "Depth " << t << " : ";
				for(int i = 0; i < GateList.size(); i++){
					if(GateList[i].readDepth()==t){
						fout1 << GateList[i].readGateName() << ", ";	
					}
				}
				fout1 << endl;
			}
			//return g-1;
		}
		tempNow.clear();
		for(int k = 0; k < tempNext.size(); k++){
			tempNow.push_back(tempNext[k]);
		}
	}
	
	//Backward Depth
	for(int i = 0; i < GateList.size(); i++){	//Clean depth
		GateList[i].updateDepth(-1);
	}	
	for(int i = 0; i < GateList.size(); i++){	//Define first class
		for(int k = 0; k < OutputName.size(); k++){
			if(GateList[i].readOutputName(0).compare(OutputName[k])==0){
				GateList[i].updateDepth(1);
				for(int j = 0; j < GateList[i].readInputLength(); j++){
					tempNow.push_back(GateList[i].readInputName(j));
				}
				break;
				break;
			}
		}
	}
	
	for(int g = 2; g < 100; g++){
		tempNext.clear();
		for(int i = 0; i < GateList.size(); i++){	//Define first class
			for(int k = 0; k < tempNow.size(); k++){
				if(GateList[i].readOutputName(0).compare(tempNow[k])==0){
					GateList[i].updateDepth(g);
					for(int j = 0; j < GateList[i].readInputLength(); j++){
						tempNext.push_back(GateList[i].readInputName(j));
					}
					break;
					break;
				}
			}
		}
		if(tempNext.empty()){
			for(int t = 1; t <= g-1; t++){
				fout1 << "Depth " << t << " : ";
				for(int i = 0; i < GateList.size(); i++){
					if(GateList[i].readDepth()==t){
						fout1 << GateList[i].readGateName() << ", ";	
					}
				}
				fout1 << endl;
			}
			return g-1;
		}
		tempNow.clear();
		for(int k = 0; k < tempNext.size(); k++){
			tempNow.push_back(tempNext[k]);
		}
	}

}

void PCHBize::countfault(){
	cout <<  "Consuming Fault : " << GateList.size()*7 << endl;
	cout <<  "Generation Fault : " << GateList.size()*10 << endl;
	int mFaultCount = 0;
	for(int i = 0; i < GateList.size(); i++){
		mFaultCount+=GateList[i].readInputLength();
	}
	cout <<  "Modification Fault : " << mFaultCount*2 << endl;
	mFaultCount = 50*GateList.size();
	for(int i = 0; i < GateList.size(); i++){
		mFaultCount+=10*GateList[i].readInputLength();
	}
	cout <<  "Total Fault : " << mFaultCount << endl;
	
	
}

PCHBgate::PCHBgate(string name, int type){
	gateName = name;
	gateType = type;
}



